// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: api/v1/challenge/challenge.proto

package challenge

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChallengeStore_CreateChallenge_FullMethodName   = "/api.v1.challenge.ChallengeStore/CreateChallenge"
	ChallengeStore_RetrieveChallenge_FullMethodName = "/api.v1.challenge.ChallengeStore/RetrieveChallenge"
	ChallengeStore_QueryChallenge_FullMethodName    = "/api.v1.challenge.ChallengeStore/QueryChallenge"
	ChallengeStore_UpdateChallenge_FullMethodName   = "/api.v1.challenge.ChallengeStore/UpdateChallenge"
	ChallengeStore_DeleteChallenge_FullMethodName   = "/api.v1.challenge.ChallengeStore/DeleteChallenge"
)

// ChallengeStoreClient is the client API for ChallengeStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The ChallengeStore holds the information related to a challenge.
// Once a challenge is stored, you can spin up instances, one per source.
// Through this store, the challenge implements all CRUD operations necessary to handle a
// lifecycle.
type ChallengeStoreClient interface {
	// Before spinning up instances of a challenge, you need to register it.
	// That is the goal of CreateChallenge.
	// If will perform validation on your inputs and especially on the scenario.
	CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error)
	// Once saved, you can retrieve the challenge information.
	// If it has not been created yet, returns an error.
	// If the challenge has instances running, returns their information too.
	RetrieveChallenge(ctx context.Context, in *RetrieveChallengeRequest, opts ...grpc.CallOption) (*Challenge, error)
	// Query all challenges information and their instances running.
	QueryChallenge(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Challenge], error)
	// A challenge can evolve through time, and on live.
	// The goal of UpdateChallenge is to handle those evolves.
	// If the until changes, sets it up to running instances.
	// If the timeout changes, set running instances until to the last renewal increased by
	// the new timeout.
	// If the scenario changes, update the running instances, but even if this is
	// technically possible we do not recommend it has we do not look for infrastructure
	// drift.
	UpdateChallenge(ctx context.Context, in *UpdateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error)
	// At the end of its life, a challenge can be deleted.
	// If it has running instances, it will spin them down.
	DeleteChallenge(ctx context.Context, in *DeleteChallengeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type challengeStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewChallengeStoreClient(cc grpc.ClientConnInterface) ChallengeStoreClient {
	return &challengeStoreClient{cc}
}

func (c *challengeStoreClient) CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Challenge)
	err := c.cc.Invoke(ctx, ChallengeStore_CreateChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeStoreClient) RetrieveChallenge(ctx context.Context, in *RetrieveChallengeRequest, opts ...grpc.CallOption) (*Challenge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Challenge)
	err := c.cc.Invoke(ctx, ChallengeStore_RetrieveChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeStoreClient) QueryChallenge(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Challenge], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChallengeStore_ServiceDesc.Streams[0], ChallengeStore_QueryChallenge_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, Challenge]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChallengeStore_QueryChallengeClient = grpc.ServerStreamingClient[Challenge]

func (c *challengeStoreClient) UpdateChallenge(ctx context.Context, in *UpdateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Challenge)
	err := c.cc.Invoke(ctx, ChallengeStore_UpdateChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeStoreClient) DeleteChallenge(ctx context.Context, in *DeleteChallengeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChallengeStore_DeleteChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChallengeStoreServer is the server API for ChallengeStore service.
// All implementations must embed UnimplementedChallengeStoreServer
// for forward compatibility.
//
// The ChallengeStore holds the information related to a challenge.
// Once a challenge is stored, you can spin up instances, one per source.
// Through this store, the challenge implements all CRUD operations necessary to handle a
// lifecycle.
type ChallengeStoreServer interface {
	// Before spinning up instances of a challenge, you need to register it.
	// That is the goal of CreateChallenge.
	// If will perform validation on your inputs and especially on the scenario.
	CreateChallenge(context.Context, *CreateChallengeRequest) (*Challenge, error)
	// Once saved, you can retrieve the challenge information.
	// If it has not been created yet, returns an error.
	// If the challenge has instances running, returns their information too.
	RetrieveChallenge(context.Context, *RetrieveChallengeRequest) (*Challenge, error)
	// Query all challenges information and their instances running.
	QueryChallenge(*emptypb.Empty, grpc.ServerStreamingServer[Challenge]) error
	// A challenge can evolve through time, and on live.
	// The goal of UpdateChallenge is to handle those evolves.
	// If the until changes, sets it up to running instances.
	// If the timeout changes, set running instances until to the last renewal increased by
	// the new timeout.
	// If the scenario changes, update the running instances, but even if this is
	// technically possible we do not recommend it has we do not look for infrastructure
	// drift.
	UpdateChallenge(context.Context, *UpdateChallengeRequest) (*Challenge, error)
	// At the end of its life, a challenge can be deleted.
	// If it has running instances, it will spin them down.
	DeleteChallenge(context.Context, *DeleteChallengeRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedChallengeStoreServer()
}

// UnimplementedChallengeStoreServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChallengeStoreServer struct{}

func (UnimplementedChallengeStoreServer) CreateChallenge(context.Context, *CreateChallengeRequest) (*Challenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChallenge not implemented")
}
func (UnimplementedChallengeStoreServer) RetrieveChallenge(context.Context, *RetrieveChallengeRequest) (*Challenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveChallenge not implemented")
}
func (UnimplementedChallengeStoreServer) QueryChallenge(*emptypb.Empty, grpc.ServerStreamingServer[Challenge]) error {
	return status.Errorf(codes.Unimplemented, "method QueryChallenge not implemented")
}
func (UnimplementedChallengeStoreServer) UpdateChallenge(context.Context, *UpdateChallengeRequest) (*Challenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChallenge not implemented")
}
func (UnimplementedChallengeStoreServer) DeleteChallenge(context.Context, *DeleteChallengeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChallenge not implemented")
}
func (UnimplementedChallengeStoreServer) mustEmbedUnimplementedChallengeStoreServer() {}
func (UnimplementedChallengeStoreServer) testEmbeddedByValue()                        {}

// UnsafeChallengeStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChallengeStoreServer will
// result in compilation errors.
type UnsafeChallengeStoreServer interface {
	mustEmbedUnimplementedChallengeStoreServer()
}

func RegisterChallengeStoreServer(s grpc.ServiceRegistrar, srv ChallengeStoreServer) {
	// If the following call pancis, it indicates UnimplementedChallengeStoreServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChallengeStore_ServiceDesc, srv)
}

func _ChallengeStore_CreateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeStoreServer).CreateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeStore_CreateChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeStoreServer).CreateChallenge(ctx, req.(*CreateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeStore_RetrieveChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeStoreServer).RetrieveChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeStore_RetrieveChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeStoreServer).RetrieveChallenge(ctx, req.(*RetrieveChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeStore_QueryChallenge_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChallengeStoreServer).QueryChallenge(m, &grpc.GenericServerStream[emptypb.Empty, Challenge]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChallengeStore_QueryChallengeServer = grpc.ServerStreamingServer[Challenge]

func _ChallengeStore_UpdateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeStoreServer).UpdateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeStore_UpdateChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeStoreServer).UpdateChallenge(ctx, req.(*UpdateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeStore_DeleteChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeStoreServer).DeleteChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeStore_DeleteChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeStoreServer).DeleteChallenge(ctx, req.(*DeleteChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChallengeStore_ServiceDesc is the grpc.ServiceDesc for ChallengeStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChallengeStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.challenge.ChallengeStore",
	HandlerType: (*ChallengeStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateChallenge",
			Handler:    _ChallengeStore_CreateChallenge_Handler,
		},
		{
			MethodName: "RetrieveChallenge",
			Handler:    _ChallengeStore_RetrieveChallenge_Handler,
		},
		{
			MethodName: "UpdateChallenge",
			Handler:    _ChallengeStore_UpdateChallenge_Handler,
		},
		{
			MethodName: "DeleteChallenge",
			Handler:    _ChallengeStore_DeleteChallenge_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryChallenge",
			Handler:       _ChallengeStore_QueryChallenge_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/challenge/challenge.proto",
}
